   1               		.file	"uart.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  99               	.global	uartInit
 101               	uartInit:
   1:uart.c        **** /*! \file uart.c \brief UART driver with buffer support. */
   2:uart.c        **** // *****************************************************************************
   3:uart.c        **** //
   4:uart.c        **** // File Name	: 'uart.c'
   5:uart.c        **** // Title		: UART driver with buffer support
   6:uart.c        **** // Author		: Pascal Stang - Copyright (C) 2000-2002
   7:uart.c        **** // Created		: 11/22/2000
   8:uart.c        **** // Revised		: 06/09/2003
   9:uart.c        **** // Version		: 1.3
  10:uart.c        **** // Target MCU	: ATMEL AVR Series
  11:uart.c        **** // Editor Tabs	: 4
  12:uart.c        **** //
  13:uart.c        **** // This code is distributed under the GNU Public License
  14:uart.c        **** //		which can be found at http://www.gnu.org/licenses/gpl.txt
  15:uart.c        **** //
  16:uart.c        **** // *****************************************************************************
  17:uart.c        **** 
  18:uart.c        **** #include <avr/io.h>
  19:uart.c        **** #include <avr/interrupt.h>
  20:uart.c        **** 
  21:uart.c        **** #include "buffer.h"
  22:uart.c        **** #include "uart.h"
  23:uart.c        **** 
  24:uart.c        **** // UART global variables
  25:uart.c        **** // flag variables
  26:uart.c        **** volatile u08   uartReadyTx;			///< uartReadyTx flag
  27:uart.c        **** volatile u08   uartBufferedTx;		///< uartBufferedTx flag
  28:uart.c        **** // receive and transmit buffers
  29:uart.c        **** cBuffer uartRxBuffer;				///< uart receive buffer
  30:uart.c        **** cBuffer uartTxBuffer;				///< uart transmit buffer
  31:uart.c        **** unsigned short uartRxOverflow;		///< receive overflow counter
  32:uart.c        **** 
  33:uart.c        **** #ifndef UART_BUFFERS_EXTERNAL_RAM
  34:uart.c        **** 	// using internal ram,
  35:uart.c        **** 	// automatically allocate space in ram for each buffer
  36:uart.c        **** 	static char uartRxData[UART_RX_BUFFER_SIZE];
  37:uart.c        **** 	static char uartTxData[UART_TX_BUFFER_SIZE];
  38:uart.c        **** #endif
  39:uart.c        **** 
  40:uart.c        **** typedef void (*voidFuncPtru08)(unsigned char);
  41:uart.c        **** volatile static voidFuncPtru08 UartRxFunc;
  42:uart.c        **** 
  43:uart.c        **** // enable and initialize the uart
  44:uart.c        **** void uartInit(void)
  45:uart.c        **** {
 102               	abn	68,0,45,.LM0-.LFBB1
 103               	.LM0:
 104               	.LFBB1:
 105 0000 DF93      		push r29
 106 0002 CF93      		push r28
 107 0004 CDB7      		in r28,__SP_L__
 108 0006 DEB7      		in r29,__SP_H__
 109               	/* prologue: function */
 110               	/* frame size = 0 */
  46:uart.c        **** 	// initialize the buffers
  47:uart.c        **** 	uartInitBuffers();
 111               	8,0,47,.LM1-.LFBB1
 112               	.LM1:
 113 0008 00D0      		rcall uartInitBuffers
  48:uart.c        **** 	// initialize user receive handler
  49:uart.c        **** 	UartRxFunc = 0;
 114               	tabn	68,0,49,.LM2-.LFBB1
 115               	.LM2:
 116 000a 1092 0000 		sts (UartRxFunc)+1,__zero_reg__
 117 000e 1092 0000 		sts UartRxFunc,__zero_reg__
  50:uart.c        **** 
  51:uart.c        **** 	// enable RxD/TxD and interrupts
  52:uart.c        **** 	outb(UCR, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
 118               	abn	68,0,52,.LM3-.LFBB1
 119               	.LM3:
 120 0012 EAE2      		ldi r30,lo8(42)
 121 0014 F0E0      		ldi r31,hi8(42)
 122 0016 88ED      		ldi r24,lo8(-40)
 123 0018 8083      		st Z,r24
  53:uart.c        **** 
  54:uart.c        **** 	// set default baud rate
  55:uart.c        **** 	uartSetBaudRate(UART_DEFAULT_BAUD_RATE);  
 124               	n	68,0,55,.LM4-.LFBB1
 125               	.LM4:
 126 001a 60E8      		ldi r22,lo8(9600)
 127 001c 75E2      		ldi r23,hi8(9600)
 128 001e 80E0      		ldi r24,hlo8(9600)
 129 0020 90E0      		ldi r25,hhi8(9600)
 130 0022 00D0      		rcall uartSetBaudRate
  56:uart.c        **** 	// initialize states
  57:uart.c        **** 	uartReadyTx = TRUE;
 131               		68,0,57,.LM5-.LFBB1
 132               	.LM5:
 133 0024 8FEF      		ldi r24,lo8(-1)
 134 0026 8093 0000 		sts uartReadyTx,r24
  58:uart.c        **** 	uartBufferedTx = FALSE;
 135               	abn	68,0,58,.LM6-.LFBB1
 136               	.LM6:
 137 002a 1092 0000 		sts uartBufferedTx,__zero_reg__
  59:uart.c        **** 	// clear overflow count
  60:uart.c        **** 	uartRxOverflow = 0;
 138               	tabn	68,0,60,.LM7-.LFBB1
 139               	.LM7:
 140 002e 1092 0000 		sts (uartRxOverflow)+1,__zero_reg__
 141 0032 1092 0000 		sts uartRxOverflow,__zero_reg__
  61:uart.c        **** 	// enable interrupts
  62:uart.c        **** 	sei();
 142               	abn	68,0,62,.LM8-.LFBB1
 143               	.LM8:
 144               	/* #APP */
 145               	 ;  62 "uart.c" 1
 146 0036 7894      		sei
 147               	 ;  0 "" 2
 148               	/* epilogue start */
  63:uart.c        **** }
 149               		68,0,63,.LM9-.LFBB1
 150               	.LM9:
 151               	/* #NOAPP */
 152 0038 CF91      		pop r28
 153 003a DF91      		pop r29
 154 003c 0895      		ret
 156               	.Lscope1:
 158               	.global	uartInitBuffers
 160               	uartInitBuffers:
  64:uart.c        **** 
  65:uart.c        **** // create and initialize the uart transmit and receive buffers
  66:uart.c        **** void uartInitBuffers(void)
  67:uart.c        **** {
 161               	,67,.LM10-.LFBB2
 162               	.LM10:
 163               	.LFBB2:
 164 003e DF93      		push r29
 165 0040 CF93      		push r28
 166 0042 CDB7      		in r28,__SP_L__
 167 0044 DEB7      		in r29,__SP_H__
 168               	/* prologue: function */
 169               	/* frame size = 0 */
  68:uart.c        **** 	#ifndef UART_BUFFERS_EXTERNAL_RAM
  69:uart.c        **** 		// initialize the UART receive buffer
  70:uart.c        **** 		bufferInit(&uartRxBuffer, uartRxData, UART_RX_BUFFER_SIZE);
 170               	8,0,70,.LM11-.LFBB2
 171               	.LM11:
 172 0046 80E0      		ldi r24,lo8(uartRxBuffer)
 173 0048 90E0      		ldi r25,hi8(uartRxBuffer)
 174 004a 20E0      		ldi r18,lo8(uartRxData)
 175 004c 30E0      		ldi r19,hi8(uartRxData)
 176 004e B901      		movw r22,r18
 177 0050 40E4      		ldi r20,lo8(64)
 178 0052 50E0      		ldi r21,hi8(64)
 179 0054 00D0      		rcall bufferInit
  71:uart.c        **** 		// initialize the UART transmit buffer
  72:uart.c        **** 		bufferInit(&uartTxBuffer, uartTxData, UART_TX_BUFFER_SIZE);
 180               	,0,72,.LM12-.LFBB2
 181               	.LM12:
 182 0056 80E0      		ldi r24,lo8(uartTxBuffer)
 183 0058 90E0      		ldi r25,hi8(uartTxBuffer)
 184 005a 20E0      		ldi r18,lo8(uartTxData)
 185 005c 30E0      		ldi r19,hi8(uartTxData)
 186 005e B901      		movw r22,r18
 187 0060 40E4      		ldi r20,lo8(64)
 188 0062 50E0      		ldi r21,hi8(64)
 189 0064 00D0      		rcall bufferInit
 190               	/* epilogue start */
  73:uart.c        **** 	#else
  74:uart.c        **** 		// initialize the UART receive buffer
  75:uart.c        **** 		bufferInit(&uartRxBuffer, (u08*) UART_RX_BUFFER_ADDR, UART_RX_BUFFER_SIZE);
  76:uart.c        **** 		// initialize the UART transmit buffer
  77:uart.c        **** 		bufferInit(&uartTxBuffer, (u08*) UART_TX_BUFFER_ADDR, UART_TX_BUFFER_SIZE);
  78:uart.c        **** 	#endif
  79:uart.c        **** }
 191               	0,79,.LM13-.LFBB2
 192               	.LM13:
 193 0066 CF91      		pop r28
 194 0068 DF91      		pop r29
 195 006a 0895      		ret
 197               	.Lscope2:
 200               	.global	uartSetRxHandler
 202               	uartSetRxHandler:
  80:uart.c        **** 
  81:uart.c        **** // redirects received data to a user function
  82:uart.c        **** void uartSetRxHandler(void (*rx_func)(unsigned char c))
  83:uart.c        **** {
 203               	,83,.LM14-.LFBB3
 204               	.LM14:
 205               	.LFBB3:
 206 006c DF93      		push r29
 207 006e CF93      		push r28
 208 0070 00D0      		rcall .
 209 0072 CDB7      		in r28,__SP_L__
 210 0074 DEB7      		in r29,__SP_H__
 211               	/* prologue: function */
 212               	/* frame size = 2 */
 213 0076 9A83      		std Y+2,r25
 214 0078 8983      		std Y+1,r24
  84:uart.c        **** 	// set the receive interrupt to run the supplied user function
  85:uart.c        **** 	UartRxFunc = rx_func;
 215               	,85,.LM15-.LFBB3
 216               	.LM15:
 217 007a 8981      		ldd r24,Y+1
 218 007c 9A81      		ldd r25,Y+2
 219 007e 9093 0000 		sts (UartRxFunc)+1,r25
 220 0082 8093 0000 		sts UartRxFunc,r24
 221               	/* epilogue start */
  86:uart.c        **** }
 222               		68,0,86,.LM16-.LFBB3
 223               	.LM16:
 224 0086 0F90      		pop __tmp_reg__
 225 0088 0F90      		pop __tmp_reg__
 226 008a CF91      		pop r28
 227 008c DF91      		pop r29
 228 008e 0895      		ret
 230               	.Lscope3:
 233               	.global	uartSetBaudRate
 235               	uartSetBaudRate:
  87:uart.c        **** 
  88:uart.c        **** // set the uart baud rate
  89:uart.c        **** void uartSetBaudRate(u32 baudrate)
  90:uart.c        **** {
 236               	0,.LM17-.LFBB4
 237               	.LM17:
 238               	.LFBB4:
 239 0090 EF92      		push r14
 240 0092 FF92      		push r15
 241 0094 0F93      		push r16
 242 0096 1F93      		push r17
 243 0098 DF93      		push r29
 244 009a CF93      		push r28
 245 009c 00D0      		rcall .
 246 009e 00D0      		rcall .
 247 00a0 00D0      		rcall .
 248 00a2 CDB7      		in r28,__SP_L__
 249 00a4 DEB7      		in r29,__SP_H__
 250               	/* prologue: function */
 251               	/* frame size = 6 */
 252 00a6 6B83      		std Y+3,r22
 253 00a8 7C83      		std Y+4,r23
 254 00aa 8D83      		std Y+5,r24
 255 00ac 9E83      		std Y+6,r25
  91:uart.c        **** 	// calculate division factor for requested baud rate, and set it
  92:uart.c        **** 	u16 bauddiv = ((F_CPU+(baudrate*8L))/(baudrate*16L)-1);
 256               	8-.LFBB4
 257               	.LM18:
 258 00ae 8B81      		ldd r24,Y+3
 259 00b0 9C81      		ldd r25,Y+4
 260 00b2 AD81      		ldd r26,Y+5
 261 00b4 BE81      		ldd r27,Y+6
 262 00b6 8058      		subi r24,lo8(-(2000000))
 263 00b8 9B47      		sbci r25,hi8(-(2000000))
 264 00ba A14E      		sbci r26,hlo8(-(2000000))
 265 00bc BF4F      		sbci r27,hhi8(-(2000000))
 266 00be 880F      		add r24,r24
 267 00c0 991F      		adc r25,r25
 268 00c2 AA1F      		adc r26,r26
 269 00c4 BB1F      		adc r27,r27
 270 00c6 880F      		add r24,r24
 271 00c8 991F      		adc r25,r25
 272 00ca AA1F      		adc r26,r26
 273 00cc BB1F      		adc r27,r27
 274 00ce 880F      		add r24,r24
 275 00d0 991F      		adc r25,r25
 276 00d2 AA1F      		adc r26,r26
 277 00d4 BB1F      		adc r27,r27
 278 00d6 7C01      		movw r14,r24
 279 00d8 8D01      		movw r16,r26
 280 00da 8B81      		ldd r24,Y+3
 281 00dc 9C81      		ldd r25,Y+4
 282 00de AD81      		ldd r26,Y+5
 283 00e0 BE81      		ldd r27,Y+6
 284 00e2 880F      		add r24,r24
 285 00e4 991F      		adc r25,r25
 286 00e6 AA1F      		adc r26,r26
 287 00e8 BB1F      		adc r27,r27
 288 00ea 880F      		add r24,r24
 289 00ec 991F      		adc r25,r25
 290 00ee AA1F      		adc r26,r26
 291 00f0 BB1F      		adc r27,r27
 292 00f2 880F      		add r24,r24
 293 00f4 991F      		adc r25,r25
 294 00f6 AA1F      		adc r26,r26
 295 00f8 BB1F      		adc r27,r27
 296 00fa 880F      		add r24,r24
 297 00fc 991F      		adc r25,r25
 298 00fe AA1F      		adc r26,r26
 299 0100 BB1F      		adc r27,r27
 300 0102 9C01      		movw r18,r24
 301 0104 AD01      		movw r20,r26
 302 0106 C801      		movw r24,r16
 303 0108 B701      		movw r22,r14
 304 010a 00D0      		rcall __udivmodsi4
 305 010c DA01      		movw r26,r20
 306 010e C901      		movw r24,r18
 307 0110 0197      		sbiw r24,1
 308 0112 9A83      		std Y+2,r25
 309 0114 8983      		std Y+1,r24
  93:uart.c        **** 	outb(UBRRL, bauddiv);
 310               	ldi r31,hi8(41)
 311               		ldd r24,Y+1
 312 0116 E9E2      		st Z,r24
 314 011a 8981      	.LM20:
 315 011c 8083      		ldi r30,lo8(64)
  94:uart.c        **** 	#ifdef UBRRH
  95:uart.c        **** 	outb(UBRRH, bauddiv>>8);
 316               	31,hi8(64)
 317               		ldd r24,Y+1
 318 011e E0E4      		ldd r25,Y+2
 319 0120 F0E0      		mov r24,r25
 320 0122 8981      		clr r25
 321 0124 9A81      		st Z,r24
 322 0126 892F      	/* epilogue start */
 324 012a 8083      	.LM21:
 325               		adiw r28,6
  96:uart.c        **** 	#endif
  97:uart.c        **** }
 326               	reg__,__SREG__
 327               		cli
 328 012c 2696      		out __SP_H__,r29
 329 012e 0FB6      		out __SREG__,__tmp_reg__
 330 0130 F894      		out __SP_L__,r28
 331 0132 DEBF      		pop r28
 332 0134 0FBE      		pop r29
 333 0136 CDBF      		pop r17
 334 0138 CF91      		pop r16
 335 013a DF91      		pop r15
 336 013c 1F91      		pop r14
 337 013e 0F91      		ret
 342               	.Lscope4:
 344               	.global	uartGetRxBuffer
 346               	uartGetRxBuffer:
 348               	.LM22:
 349               	.LFBB5:
  98:uart.c        **** 
  99:uart.c        **** // returns the receive buffer structure 
 100:uart.c        **** cBuffer* uartGetRxBuffer(void)
 101:uart.c        **** {
 350               	r28,__SP_L__
 351               		in r29,__SP_H__
 352               	/* prologue: function */
 353 0146 DF93      	/* frame size = 0 */
 355 014a CDB7      	.LM23:
 356 014c DEB7      		ldi r24,lo8(uartRxBuffer)
 357               		ldi r25,hi8(uartRxBuffer)
 358               	/* epilogue start */
 102:uart.c        **** 	// return rx buffer pointer
 103:uart.c        **** 	return &uartRxBuffer;
 359               	8,0,104,.LM24-.LFBB5
 360               	.LM24:
 361 014e 80E0      		pop r28
 362 0150 90E0      		pop r29
 363               		ret
 104:uart.c        **** }
 364               	e	uartGetRxBuffer, .-uartGetRxBuffer
 365               	.Lscope5:
 367 0154 DF91      	.global	uartGetTxBuffer
 369               	uartGetTxBuffer:
 371               	.LM25:
 372               	.LFBB6:
 373               		push r29
 374               		push r28
 105:uart.c        **** 
 106:uart.c        **** // returns the transmit buffer structure 
 107:uart.c        **** cBuffer* uartGetTxBuffer(void)
 108:uart.c        **** {
 375               	P_L__
 376               		in r29,__SP_H__
 377               	/* prologue: function */
 378 0158 DF93      	/* frame size = 0 */
 380 015c CDB7      	.LM26:
 381 015e DEB7      		ldi r24,lo8(uartTxBuffer)
 382               		ldi r25,hi8(uartTxBuffer)
 383               	/* epilogue start */
 109:uart.c        **** 	// return tx buffer pointer
 110:uart.c        **** 	return &uartTxBuffer;
 384               	8,0,111,.LM27-.LFBB6
 385               	.LM27:
 386 0160 80E0      		pop r28
 387 0162 90E0      		pop r29
 388               		ret
 111:uart.c        **** }
 389               	e	uartGetTxBuffer, .-uartGetTxBuffer
 390               	.Lscope6:
 393 0168 0895      	.global	uartSendByte
 395               	uartSendByte:
 397               	.LM28:
 398               	.LFBB7:
 399               		push r29
 400               		push r28
 112:uart.c        **** 
 113:uart.c        **** // transmits a byte over the uart
 114:uart.c        **** void uartSendByte(u08 txData)
 115:uart.c        **** {
 401               	reg__
 402               		in r28,__SP_L__
 403               		in r29,__SP_H__
 404 016a DF93      	/* prologue: function */
 405 016c CF93      	/* frame size = 1 */
 406 016e 0F92      		std Y+1,r24
 407 0170 CDB7      	.L14:
 409               	.LM29:
 410               		lds r24,uartReadyTx
 411 0174 8983      		tst r24
 412               		breq .L14
 116:uart.c        **** 	// wait for the transmitter to be ready
 117:uart.c        **** 	while(!uartReadyTx);
 413               	,119,.LM30-.LFBB7
 414               	.LM30:
 415 0176 8091 0000 		ldi r30,lo8(44)
 416 017a 8823      		ldi r31,hi8(44)
 417 017c 01F0      		ldd r24,Y+1
 118:uart.c        **** 	// send byte
 119:uart.c        **** 	outb(UDR, txData);
 418               	,r24
 420 017e ECE2      	.LM31:
 421 0180 F0E0      		sts uartReadyTx,__zero_reg__
 422 0182 8981      	/* epilogue start */
 120:uart.c        **** 	// set ready state to FALSE
 121:uart.c        **** 	uartReadyTx = FALSE;
 424               	
 425               		pop __tmp_reg__
 426 0186 1092 0000 		pop r28
 427               		pop r29
 122:uart.c        **** }
 428               	t
 430 018a 0F90      	.Lscope7:
 432 018e DF91      	.global	uartGetByte
 434               	uartGetByte:
 436               	.LM33:
 437               	.LFBB8:
 438               		push r29
 439               		push r28
 123:uart.c        **** 
 124:uart.c        **** // gets a single byte from the uart receive buffer (getchar-style)
 125:uart.c        **** int uartGetByte(void)
 126:uart.c        **** {
 440               	sh __tmp_reg__
 441               		in r28,__SP_L__
 442               		in r29,__SP_H__
 443 0192 DF93      	/* prologue: function */
 444 0194 CF93      	/* frame size = 3 */
 446 0198 0F92      	.LM34:
 447 019a CDB7      		movw r24,r28
 448 019c DEB7      		adiw r24,1
 449               		rcall uartReceiveByte
 450               		tst r24
 127:uart.c        **** 	u08 c;
 128:uart.c        **** 	if(uartReceiveByte(&c))
 452               	.LM35:
 453 019e CE01      		ldd r24,Y+1
 454 01a0 0196      		mov r18,r24
 455 01a2 00D0      		ldi r19,lo8(0)
 456 01a4 8823      		std Y+3,r19
 457 01a6 01F0      		std Y+2,r18
 129:uart.c        **** 		return c;
 458               	L18
 459               	.L17:
 461 01aa 282F      	.LM36:
 462 01ac 30E0      		ldi r24,lo8(-1)
 463 01ae 3B83      		ldi r25,hi8(-1)
 464 01b0 2A83      		std Y+3,r25
 465 01b2 00C0      		std Y+2,r24
 466               	.L18:
 130:uart.c        **** 	else
 131:uart.c        **** 		return -1;
 467               	Y+2
 468               		ldd r25,Y+3
 469 01b4 8FEF      	/* epilogue start */
 471 01b8 9B83      	.LM37:
 472 01ba 8A83      		pop __tmp_reg__
 473               		pop __tmp_reg__
 474 01bc 8A81      		pop __tmp_reg__
 475 01be 9B81      		pop r28
 476               		pop r29
 132:uart.c        **** }
 477               	e	uartGetByte, .-uartGetByte
 481 01c4 0F90      	.Lscope8:
 484 01ca 0895      	.global	uartReceiveByte
 486               	uartReceiveByte:
 488               	.LM38:
 489               	.LFBB9:
 490               		push r29
 491               		push r28
 492               		rcall .
 493               		push __tmp_reg__
 494               		in r28,__SP_L__
 133:uart.c        **** 
 134:uart.c        **** // gets a byte (if available) from the uart receive buffer
 135:uart.c        **** u08 uartReceiveByte(u08* rxData)
 136:uart.c        **** {
 495               	* prologue: function */
 496               	/* frame size = 3 */
 497               		std Y+2,r25
 498 01cc DF93      		std Y+1,r24
 500 01d0 00D0      	.LM39:
 501 01d2 0F92      		lds r24,uartRxBuffer+2
 502 01d4 CDB7      		lds r25,(uartRxBuffer+2)+1
 503 01d6 DEB7      		sbiw r24,0
 504               		breq .L21
 506 01d8 9A83      	.LM40:
 507 01da 8983      		lds r24,uartRxBuffer+4
 137:uart.c        **** 	// make sure we have a receive buffer
 138:uart.c        **** 	if(uartRxBuffer.size)
 508               	tRxBuffer+4)+1
 509               		sbiw r24,0
 510 01dc 8091 0000 		breq .L22
 512 01e4 0097      	.LM41:
 513 01e6 01F0      		ldi r24,lo8(uartRxBuffer)
 139:uart.c        **** 	{
 140:uart.c        **** 		// make sure we have data
 141:uart.c        **** 		if(uartRxBuffer.datalength)
 514               	25,hi8(uartRxBuffer)
 515               		rcall bufferGetFromFront
 516 01e8 8091 0000 		ldd r30,Y+1
 517 01ec 9091 0000 		ldd r31,Y+2
 518 01f0 0097      		st Z,r24
 142:uart.c        **** 		{
 143:uart.c        **** 			// get byte from beginning of buffer
 144:uart.c        **** 			*rxData = bufferGetFromFront(&uartRxBuffer);
 520               	
 521               		ldi r24,lo8(-1)
 522 01f4 80E0      		std Y+3,r24
 523 01f6 90E0      		rjmp .L23
 524 01f8 00D0      	.L22:
 526 01fc FA81      	.LM43:
 527 01fe 8083      		std Y+3,__zero_reg__
 145:uart.c        **** 			return TRUE;
 528               	L23
 529               	.L21:
 531 0202 8B83      	.LM44:
 532 0204 00C0      		std Y+3,__zero_reg__
 533               	.L23:
 146:uart.c        **** 		}
 147:uart.c        **** 		else
 148:uart.c        **** 		{
 149:uart.c        **** 			// no data
 150:uart.c        **** 			return FALSE;
 534               	24,Y+3
 535               	/* epilogue start */
 537 0208 00C0      	.LM45:
 538               		pop __tmp_reg__
 151:uart.c        **** 		}
 152:uart.c        **** 	}
 153:uart.c        **** 	else
 154:uart.c        **** 	{
 155:uart.c        **** 		// no buffer
 156:uart.c        **** 		return FALSE;
 539               	__tmp_reg__
 540               		pop __tmp_reg__
 541 020a 1B82      		pop r28
 542               		pop r29
 543 020c 8B81      		ret
 157:uart.c        **** 	}
 158:uart.c        **** }
 545               	e9:
 547 020e 0F90      	.global	uartFlushReceiveBuffer
 549 0212 0F90      	uartFlushReceiveBuffer:
 551 0216 DF91      	.LM46:
 552 0218 0895      	.LFBB10:
 553               		push r29
 554               		push r28
 555               		in r28,__SP_L__
 556               		in r29,__SP_H__
 557               	/* prologue: function */
 558               	/* frame size = 0 */
 159:uart.c        **** 
 160:uart.c        **** // flush all data out of the receive buffer
 161:uart.c        **** void uartFlushReceiveBuffer(void)
 162:uart.c        **** {
 559               	66,.LM47-.LFBB10
 560               	.LM47:
 561               		sts (uartRxBuffer+4)+1,__zero_reg__
 562 021a DF93      		sts uartRxBuffer+4,__zero_reg__
 563 021c CF93      	/* epilogue start */
 565 0220 DEB7      	.LM48:
 566               		pop r28
 567               		pop r29
 163:uart.c        **** 	// flush all data from receive buffer
 164:uart.c        **** 	//bufferFlush(&uartRxBuffer);
 165:uart.c        **** 	// same effect as above
 166:uart.c        **** 	uartRxBuffer.datalength = 0;
 568               	ze	uartFlushReceiveBuffer, .-uartFlushReceiveBuffer
 569               	.Lscope10:
 571 0226 1092 0000 	.global	uartReceiveBufferIsEmpty
 167:uart.c        **** }
 573               	eceiveBufferIsEmpty:
 575 022a CF91      	.LM49:
 576 022c DF91      	.LFBB11:
 577 022e 0895      		push r29
 578               		push r28
 579               		push __tmp_reg__
 580               		in r28,__SP_L__
 581               		in r29,__SP_H__
 582               	/* prologue: function */
 583               	/* frame size = 1 */
 168:uart.c        **** 
 169:uart.c        **** // return true if uart receive buffer is empty
 170:uart.c        **** u08 uartReceiveBufferIsEmpty(void)
 171:uart.c        **** {
 584               	0,172,.LM50-.LFBB11
 585               	.LM50:
 586               		lds r24,uartRxBuffer+4
 587 0230 DF93      		lds r25,(uartRxBuffer+4)+1
 588 0232 CF93      		sbiw r24,0
 589 0234 0F92      		brne .L28
 591 0238 DEB7      	.LM51:
 592               		ldi r24,lo8(-1)
 593               		std Y+1,r24
 172:uart.c        **** 	if(uartRxBuffer.datalength == 0)
 594               	
 595               	.L28:
 597 023e 9091 0000 	.LM52:
 598 0242 0097      		std Y+1,__zero_reg__
 599 0244 01F4      	.L29:
 173:uart.c        **** 	{
 174:uart.c        **** 		return TRUE;
 600               	r24,Y+1
 601               	/* epilogue start */
 603 0248 8983      	.LM53:
 604 024a 00C0      		pop __tmp_reg__
 605               		pop r28
 175:uart.c        **** 	}
 176:uart.c        **** 	else
 177:uart.c        **** 	{
 178:uart.c        **** 		return FALSE;
 606               	29
 607               		ret
 609               	.Lscope11:
 179:uart.c        **** 	}
 180:uart.c        **** }
 612               	l	uartAddToTxBuffer
 614 0250 0F90      	uartAddToTxBuffer:
 616 0254 DF91      	.LM54:
 617 0256 0895      	.LFBB12:
 618               		push r29
 619               		push r28
 620               		push __tmp_reg__
 621               		in r28,__SP_L__
 622               		in r29,__SP_H__
 623               	/* prologue: function */
 624               	/* frame size = 1 */
 181:uart.c        **** 
 182:uart.c        **** // add byte to end of uart Tx buffer
 183:uart.c        **** u08 uartAddToTxBuffer(u08 data)
 184:uart.c        **** {
 626               	.LM55:
 627               		ldi r24,lo8(uartTxBuffer)
 628 0258 DF93      		ldi r25,hi8(uartTxBuffer)
 629 025a CF93      		ldd r22,Y+1
 630 025c 0F92      		rcall bufferAddToEnd
 631 025e CDB7      	/* epilogue start */
 633               	.LM56:
 634               		pop __tmp_reg__
 635 0262 8983      		pop r28
 185:uart.c        **** 	// add data byte to the end of the tx buffer
 186:uart.c        **** 	return bufferAddToEnd(&uartTxBuffer, data);
 636               	et
 638 0264 80E0      	.Lscope12:
 640 0268 6981      	.global	uartSendTxBuffer
 642               	uartSendTxBuffer:
 187:uart.c        **** }
 643               		68,0,191,.LM57-.LFBB13
 644               	.LM57:
 645 026c 0F90      	.LFBB13:
 646 026e CF91      		push r29
 647 0270 DF91      		push r28
 648 0272 0895      		in r28,__SP_L__
 649               		in r29,__SP_H__
 650               	/* prologue: function */
 651               	/* frame size = 0 */
 653               	.LM58:
 654               		ldi r24,lo8(-1)
 188:uart.c        **** 
 189:uart.c        **** // start transmission of the current uart Tx buffer contents
 190:uart.c        **** void uartSendTxBuffer(void)
 191:uart.c        **** {
 655               	on
 656               	uartSendTxBuffer:
 658 0274 DF93      	.LM57:
 659 0276 CF93      	.LFBB13:
 660 0278 CDB7      		push r29
 661 027a DEB7      		push r28
 662               		in r28,__SP_L__
 663               		in r29,__SP_H__
 192:uart.c        **** 	// turn on buffered transmit
 193:uart.c        **** 	uartBufferedTx = TRUE;
 664               	artSendTxBuffer:F(0,15)",36,0,0,uartSendTxBuffer
 665               	.global	uartSendTxBuffer
 667 027e 8093 0000 	uartSendTxBuffer:
 194:uart.c        **** 	// send the first byte to get things going by interrupts
 195:uart.c        **** 	uartSendByte(bufferGetFromFront(&uartTxBuffer));
 668               	abn	68,0,191,.LM57-.LFBB13
 669               	.LM57:
 670 0282 80E0      	.LFBB13:
 671 0284 90E0      		push r29
 672 0286 00D0      		push r28
 673 0288 00D0      		in r28,__SP_L__
 674               		in r29,__SP_H__
 196:uart.c        **** }
 675               	artSendTxBuffer:F(0,15)",36,0,0,uartSendTxBuffer
 676               	.global	uartSendTxBuffer
 678 028c DF91      	uartSendTxBuffer:
 680               	.LM57:
 681               	.LFBB13:
 682               		push r29
 683               		push r28
 684               		in r28,__SP_L__
 685               		in r29,__SP_H__
 197:uart.c        **** /*
 198:uart.c        **** // transmit nBytes from buffer out the uart
 199:uart.c        **** u08 uartSendBuffer(char *buffer, u16 nBytes)
 200:uart.c        **** {
 201:uart.c        **** 	register u08 first;
 202:uart.c        **** 	register u16 i;
 203:uart.c        **** 
 204:uart.c        **** 	// check if there's space (and that we have any bytes to send at all)
 205:uart.c        **** 	if((uartTxBuffer.datalength + nBytes < uartTxBuffer.size) && nBytes)
 206:uart.c        **** 	{
 207:uart.c        **** 		// grab first character
 208:uart.c        **** 		first = *buffer++;
 209:uart.c        **** 		// copy user buffer to uart transmit buffer
 210:uart.c        **** 		for(i = 0; i < nBytes-1; i++)
 211:uart.c        **** 		{
 212:uart.c        **** 			// put data bytes at end of buffer
 213:uart.c        **** 			bufferAddToEnd(&uartTxBuffer, *buffer++);
 214:uart.c        **** 		}
 215:uart.c        **** 
 216:uart.c        **** 		// send the first byte to get things going by interrupts
 217:uart.c        **** 		uartBufferedTx = TRUE;
 218:uart.c        **** 		uartSendByte(first);
 219:uart.c        **** 		// return success
 220:uart.c        **** 		return TRUE;
 221:uart.c        **** 	}
 222:uart.c        **** 	else
 223:uart.c        **** 	{
 224:uart.c        **** 		// return failure
 225:uart.c        **** 		return FALSE;
 226:uart.c        **** 	}
 227:uart.c        **** }
 228:uart.c        **** */
 229:uart.c        **** // UART Transmit Complete Interrupt Handler
 230:uart.c        **** UART_INTERRUPT_HANDLER(SIG_UART_TRANS)
 231:uart.c        **** {
 686               	: function */
 687               	/* frame size = 0 */
 689 0290 1F92      	.LM58:
 690 0292 0F92      		ldi r24,lo8(-1)
 691 0294 0FB6      		sts uartBufferedTx,r24
 693 0298 1124      	.LM59:
 694 029a 0F93      		ldi r24,lo8(uartTxBuffer)
 695 029c 1F93      		ldi r25,hi8(uartTxBuffer)
 696 029e 2F93      		rcall bufferGetFromFront
 697 02a0 3F93      		rcall uartSendByte
 698 02a2 4F93      	/* epilogue start */
 700 02a6 6F93      	.LM60:
 701 02a8 7F93      		pop r28
 702 02aa 8F93      		pop r29
 703 02ac 9F93      		ret
 705 02b0 BF93      	.Lscope13:
 707 02b4 FF93      	.global	__vector_13
 709 02b8 CF93      	__vector_13:
 711 02bc DEB7      	.LM61:
 712               	.LFBB14:
 713               		push __zero_reg__
 232:uart.c        **** 	// check if buffered tx is enabled
 233:uart.c        **** 	if(uartBufferedTx)
 714               	ndTxBuffer
 715               	.Lscope13:
 717 02c2 8823      	.global	__vector_13
 234:uart.c        **** 	{
 235:uart.c        **** 		// check if there's data left in the buffer
 236:uart.c        **** 		if(uartTxBuffer.datalength)
 719               	,0,196,.LM60-.LFBB13
 720               	.LM60:
 721 02c6 8091 0000 		pop r28
 722 02ca 9091 0000 		pop r29
 723 02ce 0097      		ret
 237:uart.c        **** 		{
 238:uart.c        **** 			// send byte from top of buffer
 239:uart.c        **** 			outb(UDR, bufferGetFromFront(&uartTxBuffer));
 725               	TxBuffer)
 726               		ldi r25,hi8(uartTxBuffer)
 727 02d2 0CE2      		rcall bufferGetFromFront
 728 02d4 10E0      		rcall uartSendByte
 729 02d6 80E0      	/* epilogue start */
 731 02da 00D0      	.LM60:
 732 02dc F801      		pop r28
 733 02de 8083      		pop r29
 734 02e0 00C0      		ret
 240:uart.c        **** 		}
 241:uart.c        **** 		else
 242:uart.c        **** 		{
 243:uart.c        **** 			// no data left
 244:uart.c        **** 			uartBufferedTx = FALSE;
 736               	TxBuffer)
 737               		ldi r25,hi8(uartTxBuffer)
 738 02e2 1092 0000 		rcall bufferGetFromFront
 245:uart.c        **** 			// return to ready state
 246:uart.c        **** 			uartReadyTx = TRUE;
 739               	* frame size = 0 */
 741 02e6 8FEF      	.LM58:
 742 02e8 8093 0000 		ldi r24,lo8(-1)
 743 02ec 00C0      		sts uartBufferedTx,r24
 247:uart.c        **** 		}
 248:uart.c        **** 	}
 249:uart.c        **** 	else
 250:uart.c        **** 	{
 251:uart.c        **** 		// we're using single-byte tx mode
 252:uart.c        **** 		// indicate transmit complete, back to ready
 253:uart.c        **** 		uartReadyTx = TRUE;
 745               	:
 746               	.LFBB13:
 747 02ee 8FEF      		push r29
 748 02f0 8093 0000 		push r28
 749               		in r28,__SP_L__
 750               		in r29,__SP_H__
 254:uart.c        **** 	}
 255:uart.c        **** }
 751               	artSendTxBuffer:F(0,15)",36,0,0,uartSendTxBuffer
 752               	.global	uartSendTxBuffer
 754 02f6 DF91      	uartSendTxBuffer:
 756 02fa EF91      	.LM57:
 757 02fc BF91      	.LFBB13:
 758 02fe AF91      		push r29
 759 0300 9F91      		push r28
 760 0302 8F91      		in r28,__SP_L__
 761 0304 7F91      		in r29,__SP_H__
 762 0306 6F91      	/* prologue: function */
 763 0308 5F91      	/* frame size = 0 */
 765 030c 3F91      	.LM58:
 766 030e 2F91      		ldi r24,lo8(-1)
 767 0310 1F91      		sts uartBufferedTx,r24
 769 0314 0F90      	.LM59:
 770 0316 0FBE      		ldi r24,lo8(uartTxBuffer)
 771 0318 0F90      		ldi r25,hi8(uartTxBuffer)
 772 031a 1F90      		rcall bufferGetFromFront
 773 031c 1895      		rcall uartSendByte
 774               	/* epilogue start */
 776               	.LM60:
 777               		pop r28
 778               		pop r29
 779               		ret
 256:uart.c        **** 
 257:uart.c        **** // UART Receive Complete Interrupt Handler
 258:uart.c        **** UART_INTERRUPT_HANDLER(SIG_UART_RECV)
 259:uart.c        **** {
 780               	rtSendTxBuffer
 781               	.Lscope13:
 783 031e 1F92      	.global	__vector_13
 785 0322 0FB6      	__vector_13:
 787 0326 1124      	.LM61:
 788 0328 2F93      	.LFBB14:
 789 032a 3F93      		push __zero_reg__
 790 032c 4F93      		push r0
 791 032e 5F93      		in r0,__SREG__
 792 0330 6F93      		push r0
 793 0332 7F93      		clr __zero_reg__
 794 0334 8F93      		push r16
 795 0336 9F93      		push r17
 796 0338 AF93      		push r18
 797 033a BF93      		push r19
 798 033c EF93      		push r20
 799 033e FF93      		push r21
 800 0340 DF93      		push r22
 801 0342 CF93      		push r23
 802 0344 0F92      		push r24
 803 0346 CDB7      		push r25
 804 0348 DEB7      		push r26
 805               		push r27
 806               		push r30
 260:uart.c        **** 	u08 c;
 261:uart.c        **** 	
 262:uart.c        **** 	// get received char
 263:uart.c        **** 	c = inb(UDR);
 807               	
 808               		push r0
 809 034a ECE2      		in r0,__SREG__
 810 034c F0E0      		push r0
 811 034e 8081      		clr __zero_reg__
 812 0350 8983      		push r16
 264:uart.c        **** 
 265:uart.c        **** 	// if there's a user function to handle this receive event
 266:uart.c        **** 	if(UartRxFunc)
 813               	_13
 814               	.global	__vector_13
 816 0356 9091 0000 	__vector_13:
 818 035c 01F0      	.LM61:
 267:uart.c        **** 	{
 268:uart.c        **** 		// call it and pass the received data
 269:uart.c        **** 		UartRxFunc(c);
 819               	ize	uartSendTxBuffer, .-uartSendTxBuffer
 820               	.Lscope13:
 822 0362 F091 0000 	.global	__vector_13
 824 0368 0995      	__vector_13:
 826               	.LM61:
 270:uart.c        **** 	}
 271:uart.c        **** 	else
 272:uart.c        **** 	{
 273:uart.c        **** 		// otherwise do default processing
 274:uart.c        **** 		// put received char in buffer
 275:uart.c        **** 		// check if there's space
 276:uart.c        **** 		if( !bufferAddToEnd(&uartRxBuffer, c) )
 827               	ize	uartSendTxBuffer, .-uartSendTxBuffer
 828               	.Lscope13:
 830 036e 90E0      	.global	__vector_13
 832 0372 00D0      	__vector_13:
 834 0376 01F4      	.LM61:
 277:uart.c        **** 		{
 278:uart.c        **** 			// no space in buffer
 279:uart.c        **** 			// count overflow
 280:uart.c        **** 			uartRxOverflow++;
 835               	ize	uartSendTxBuffer, .-uartSendTxBuffer
 836               	.Lscope13:
 838 037c 9091 0000 	.global	__vector_13
 840 0382 9093 0000 	__vector_13:
 842               	.LM61:
 843               	.LFBB14:
 281:uart.c        **** 		}
 282:uart.c        **** 	}
 283:uart.c        **** }
 844               	ndTxBuffer, .-uartSendTxBuffer
 845               	.Lscope13:
 847 038c CF91      	.global	__vector_13
 849 0390 FF91      	__vector_13:
 851 0394 BF91      	.LM61:
 852 0396 AF91      	.LFBB14:
 853 0398 9F91      		push __zero_reg__
 854 039a 8F91      		push r0
 855 039c 7F91      		in r0,__SREG__
 856 039e 6F91      		push r0
 857 03a0 5F91      		clr __zero_reg__
 858 03a2 4F91      		push r16
 859 03a4 3F91      		push r17
 860 03a6 2F91      		push r18
 861 03a8 0F90      		push r19
 862 03aa 0FBE      		push r20
 863 03ac 0F90      		push r21
 864 03ae 1F90      		push r22
 865 03b0 1895      		push r23
 866               		push r24
 867               		push r25
 868               		push r26
 869               		push r27
 870               		push r30
 871               		push r31
 872               		push r29
 873               		push r28
 874               		in r28,__SP_L__
 875               		in r29,__SP_H__
 876               	/* prologue: Signal */
 877               	/* frame size = 0 */
 879               	.LM62:
 880               		lds r24,uartBufferedTx
 881               		tst r24
 882               		breq .L36
 884               	.LM63:
 885               		lds r24,uartTxBuffer+4
 886               		lds r25,(uartTxBuffer+4)+1
 887               		sbiw r24,0
 888               		breq .L37
DEFINED SYMBOLS
                            *ABS*:00000000 uart.c
C:\Users\YASHMA~1\AppData\Local\Temp/cccAW6iM.s:2      *ABS*:0000003f __SREG__
C:\Users\YASHMA~1\AppData\Local\Temp/cccAW6iM.s:3      *ABS*:0000003e __SP_H__
C:\Users\YASHMA~1\AppData\Local\Temp/cccAW6iM.s:4      *ABS*:0000003d __SP_L__
C:\Users\YASHMA~1\AppData\Local\Temp/cccAW6iM.s:5      *ABS*:00000034 __CCP__
C:\Users\YASHMA~1\AppData\Local\Temp/cccAW6iM.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\YASHMA~1\AppData\Local\Temp/cccAW6iM.s:7      *ABS*:00000001 __zero_reg__
C:\Users\YASHMA~1\AppData\Local\Temp/cccAW6iM.s:101    .text:00000000 uartInit
C:\Users\YASHMA~1\AppData\Local\Temp/cccAW6iM.s:160    .text:0000003e uartInitBuffers
C:\Users\YASHMA~1\AppData\Local\Temp/cccAW6iM.s:872    .bss:00000080 UartRxFunc
C:\Users\YASHMA~1\AppData\Local\Temp/cccAW6iM.s:235    .text:00000090 uartSetBaudRate
                            *COM*:00000001 uartReadyTx
                            *COM*:00000001 uartBufferedTx
                            *COM*:00000002 uartRxOverflow
                            *COM*:00000008 uartRxBuffer
                             .bss:00000000 uartRxData
                            *COM*:00000008 uartTxBuffer
C:\Users\YASHMA~1\AppData\Local\Temp/cccAW6iM.s:871    .bss:00000040 uartTxData
C:\Users\YASHMA~1\AppData\Local\Temp/cccAW6iM.s:202    .text:0000006c uartSetRxHandler
C:\Users\YASHMA~1\AppData\Local\Temp/cccAW6iM.s:349    .text:00000146 uartGetRxBuffer
C:\Users\YASHMA~1\AppData\Local\Temp/cccAW6iM.s:374    .text:00000158 uartGetTxBuffer
C:\Users\YASHMA~1\AppData\Local\Temp/cccAW6iM.s:400    .text:0000016a uartSendByte
C:\Users\YASHMA~1\AppData\Local\Temp/cccAW6iM.s:439    .text:00000192 uartGetByte
C:\Users\YASHMA~1\AppData\Local\Temp/cccAW6iM.s:494    .text:000001cc uartReceiveByte
C:\Users\YASHMA~1\AppData\Local\Temp/cccAW6iM.s:558    .text:0000021a uartFlushReceiveBuffer
C:\Users\YASHMA~1\AppData\Local\Temp/cccAW6iM.s:583    .text:00000230 uartReceiveBufferIsEmpty
C:\Users\YASHMA~1\AppData\Local\Temp/cccAW6iM.s:624    .text:00000258 uartAddToTxBuffer
C:\Users\YASHMA~1\AppData\Local\Temp/cccAW6iM.s:654    .text:00000274 uartSendTxBuffer
C:\Users\YASHMA~1\AppData\Local\Temp/cccAW6iM.s:685    .text:00000290 __vector_13
C:\Users\YASHMA~1\AppData\Local\Temp/cccAW6iM.s:779    .text:0000031e __vector_11

UNDEFINED SYMBOLS
bufferInit
__udivmodsi4
bufferGetFromFront
bufferAddToEnd
__do_clear_bss
